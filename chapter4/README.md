# item23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라

* 계층 구조의 루트(?) 공통으로 사용되는 메소드를 추상 클래스에 정의하고, 태그 값(?)에 따라
  동작이 달라지는 메서드들을 루트 클래스(추상 클래스)의 추상 메서드로 선언한다. <br />

* 클래스 계층 구조 : 독립된 클래스의 집합, 타입 사이의 자연스러운 계층 관계 반영

<br />
Q. 태크 달린 클래스 / 태그 필드 / 태그 값 으로 표현되는 '태그'가 정확하게 어떤 의미에서 이렇게 번역된 것인지 이해가 잘 안됩니다. 
<br />
<hr /><br/>

# item24. 멤버 클래스는 되도록 static으로 만들어라

* 중첩 클래스, 내부 클래스라고도 불림 (inner class) - 클래스 내부에 클래스를 선언하여 외부 클래스의
  필드 접근에 용이

* 궁극적 목적 : '캡슐화'

* 정적(메모리) (static) - application이 실행되면 모두 메모리에 할당되고, 종료되면 삭제됨
* 비정적(메모리) (non-static) - 클래스의 인스턴스를 생성할 때 만들어짐
<pre>
<code>
[형식]
class Outer {
    static class Inner {
        인스턴스 요소;
        static 요소;
    }
}
[객체 생성]
Outer.Inner stin = new Inner();
// Outer 클래스의 객체가 없어도 Inner 클래스의 객체 생성 가능
stin.인스턴스필드 = 3;
stin.인스턴스메서드();
Outer.Inner.정적필드 = 3;
Outer.Inner.정적메서드();
// 정적요소에 접근할 때는 인스턴스가 존재하지 않아, 클래스로 접근 뒤 정적요소에 접근함
</code>
</pre>

ex) Map 구현체의 각각 키-값 쌍을 표현하는 Entry 객체 - Map을 직접 사용 X, Entry를 non-static으로 표현하는 것은 낭비이고,
private static 클래스가 알맞음 => Entry가 직접적으로 Map을 사용, 참조하지 않으므로, 독립적인(?) static이 맞음


<br />
* 익명 클래스 - 익명 구현 객체를 만들고, 일회성의 목적. 즉, 메모리 heap영역에 객체를 기록할 뿐, 
객체의 이름은 없다. 재사용성이 없고, 확장성을 활용하는 것이 유지보수에 더 불리할 때 
<br />

* 지역 클래스 (지역 변수처럼 쓰이는 것)
    * 메소드 안에서 정의된다.
    * default 이거나 final, abstract 로만 선언 가능
    * 지역클래스를 포함하는 메소드 안에서만 객체를 생성할 수 있으며, 메소드의 실행이 끝나면 해당 지역 클래스가 메모리에서 사라진

<br />
Q. 비정적(non-static)멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결된다? <br />
Q. 중첩 클래스의 인스턴스가 바깥 인스턴스와 독립적으로 존재할 수 있다면 정적(static) 멤버 클래스로 만들어야한다? 
<br />
<hr /><br/>

# item25. 톱레벨 클래스는 한 파일에 하나만 담으라
* 소스 파일 하나에는 반드시 톱레벨 클래스 (혹은 톱레벨 인터페이스) 하나만 담아야 한다. <br />
  컴파일러에 어떤 소스파일이 먼저 건네지느냐에 따라 동작이 달라지므로 <br />
  해결 => 여러 톱레벨 클래스를 한 파일에 담고 싶다면, 부차적 클래스를 정적 멤버 클래스로 만들 것 